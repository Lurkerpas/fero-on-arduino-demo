/* File generated by kazoo for TASTE - do not edit */
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#define RUNTIME_TASK_COUNT ( 1 + 3 + 0 )
#define RUNTIME_FUNCTION_COUNT ( 1 + 3 + (0 * 2) )

#define PROVIDED_INTERFACE_COUNT ( 0 + 1+ 1+ 1+ 1+ 1 )

extern "C" {
#include <fero.h>
#include <Broker.h>
#include <DriverHelper.h>
#include "partition_1_interface.h"
#include "transport.h"
#include "routing.h"
#include "thread_corecomponent_tc.h"
#include "thread_orchestratorcomponent_tm.h"
#include "thread_orchestratorcomponent_trigger.h"
#include "interfaces_info.h"

extern void init_orchestratorcomponent(void);
extern void init_corecomponent(void);
extern void init_utilitycomponent(void);

void ardu_print(char* data);
void int_to_string(asn1SccTestInteger value, char* buffer);
}

FERO_SCHEDULER_BUFFER(scheduler_buffer, RUNTIME_TASK_COUNT);
Fero_Scheduler scheduler;

driver_send_function bus_to_driver_send_function[SYSTEM_BUSES_NUMBER];
void* bus_to_driver_private_data[SYSTEM_BUSES_NUMBER];
enum PacketizerCfg bus_to_packetizer_cfg[SYSTEM_BUSES_NUMBER];
deliver_function interface_to_deliver_function[INTERFACE_MAX_ID];
enum RemoteInterface bus_to_unique_port_map[SYSTEM_BUSES_NUMBER] = {INTERFACE_INVALID_ID};
int bus_has_any_destination_port[SYSTEM_BUSES_NUMBER] = {0};

static void initialize_devices()
{
    for(int i = 0; i < SYSTEM_BUSES_NUMBER; ++i)
    {
        bus_to_driver_send_function[i] = NULL;
        bus_to_driver_private_data[i] = NULL;
        bus_to_packetizer_cfg[i] = PACKETIZER_DEFAULT;
    }

    // register send functions

    // initialize devices
}

FERO_QUEUE_BUFFER(corecomponent_tc_queue_buffer, 1, sizeof(struct ThreadCorecomponent_TcRequest));
Fero_Tasklet corecomponent_tc_tasklet;
Fero_Queue corecomponent_tc_queue;


static void create_tasklet_corecomponent_tc(void)
{
    Fero_Tasklet_init(
        &corecomponent_tc_tasklet,
        "corecomponent_tc_tasklet",
        corecomponent_tc_job,
        NULL
    );

    Fero_Scheduler_addTasklet(
        &scheduler,
        &corecomponent_tc_tasklet,
        0
    );

    Fero_Queue_init(
        &corecomponent_tc_queue,
        1,
        sizeof(struct ThreadCorecomponent_TcRequest),
        corecomponent_tc_queue_buffer
    );

    Fero_Tasklet_setQueueActivated(
        &corecomponent_tc_tasklet,
        &corecomponent_tc_queue
    );
}


FERO_QUEUE_BUFFER(orchestratorcomponent_tm_queue_buffer, 1, sizeof(struct ThreadOrchestratorcomponent_TmRequest));
Fero_Tasklet orchestratorcomponent_tm_tasklet;
Fero_Queue orchestratorcomponent_tm_queue;

static void create_tasklet_orchestratorcomponent_tm(void)
{
    Fero_Tasklet_init(
        &orchestratorcomponent_tm_tasklet,
        "orchestratorcomponent_tm_tasklet",
        orchestratorcomponent_tm_job,
        NULL
    );

    Fero_Scheduler_addTasklet(
        &scheduler,
        &orchestratorcomponent_tm_tasklet,
        0
    );

    Fero_Queue_init(
        &orchestratorcomponent_tm_queue,
        1,
        sizeof(struct ThreadOrchestratorcomponent_TmRequest),
        orchestratorcomponent_tm_queue_buffer
    );

    Fero_Tasklet_setQueueActivated(
        &orchestratorcomponent_tm_tasklet,
        &orchestratorcomponent_tm_queue
    );
}



Fero_Tasklet orchestratorcomponent_trigger_tasklet;

static void create_tasklet_orchestratorcomponent_trigger(void)
{
    Fero_Tasklet_init(
        &orchestratorcomponent_trigger_tasklet,
        "orchestratorcomponent_trigger",
        orchestratorcomponent_trigger_job,
        NULL
    );

    Fero_Scheduler_addTasklet(
        &scheduler,
        &orchestratorcomponent_trigger_tasklet,
        0
    );

    Fero_TimeNs period = 1000 * 1000000;
    Fero_TimeNs offset = 0;

    Fero_Tasklet_setPeriodic(
        &orchestratorcomponent_trigger_tasklet,
        period,
        offset
    );
}

// Hacks for writing to console from functions;
// Ugly, but this is just demo code
void ardu_print(char* data)
{
    const size_t len = strlen(data);
    while (Serial.availableForWrite() < len )
    {
        // NOP
        // Serial.flush(); does not seem to work on qemu
    }
    Serial.print(data);
}

void int_to_string(asn1SccTestInteger value, char* buffer) {
   if (value == 0) {
      buffer[0] = '0';
      buffer[1] = '\0';
      return;
   }
   
   int index = 0;
   
   while (value > 0) {
      buffer[index++] = '0' + (value % 10);
      value /= 10;
   }
   
   int start = 0;
   int end = index - 1;
   while (start < end) {
      char temp = buffer[start];
      buffer[start] = buffer[end];
      buffer[end] = temp;
      start++;
      end--;
   }
   
   buffer[index] = '\0';
}

void setup()
{
    Serial.begin(9600);
    initialize_devices();
    initialize_transport();
    initialize_routing();

    enum SystemBus valid_buses[SYSTEM_BUSES_NUMBER] = { BUS_INVALID_ID };
    Broker_initialize(valid_buses);

        Fero_Scheduler_init(
        &scheduler,
        RUNTIME_TASK_COUNT,
        scheduler_buffer
    );

    init_orchestratorcomponent();
    init_corecomponent();
    init_utilitycomponent();

    create_tasklet_corecomponent_tc();
    create_tasklet_orchestratorcomponent_tm();
    create_tasklet_orchestratorcomponent_trigger();
}

void loop()
{
    // Fero_TimeNs time = millis() * 1000000;
    // Workaround for millis not working on AVR Qemu
    static Fero_TimeNs time = 0;
    time += 1000000;
    Fero_Scheduler_invoke(&scheduler, time);
}
