/* File generated by kazoo for TASTE - do not edit */
#include <rtems.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <CbiPartitionApi.h>

#define RUNTIME_TASK_COUNT ( 1 + 3 + 0 )
#define RUNTIME_FUNCTION_COUNT ( 1 + 3 + (0 * 2) )

#define PROVIDED_INTERFACE_COUNT ( 0 + 1+ 1+ 1+ 1+ 1 )

#define MAX_TLS_SIZE RTEMS_ALIGN_UP( ((64 > (8 * PROVIDED_INTERFACE_COUNT)) ? 64 : (8 * PROVIDED_INTERFACE_COUNT)), RTEMS_TASK_STORAGE_ALIGNMENT )

#define TASK_ATTRIBUTES RTEMS_DEFAULT_ATTRIBUTES

#define TASK_STORAGE_SIZE \
  RTEMS_TASK_STORAGE_SIZE( \
    MAX_TLS_SIZE + RTEMS_MINIMUM_STACK_SIZE, \
    TASK_ATTRIBUTES \
  )

#include "partition_1_interface.h"
#include "transport.h"
#include "routing.h"

#include <Broker.h>
#include <DriverHelper.h>


#include "thread_corecomponent_tc.h"
#include "thread_orchestratorcomponent_tm.h"
#include "thread_orchestratorcomponent_trigger.h"

#include "interfaces_info.h"

extern void init_orchestratorcomponent(void);
extern void init_corecomponent(void);
extern void init_utilitycomponent(void);


driver_send_function bus_to_driver_send_function[SYSTEM_BUSES_NUMBER];
void* bus_to_driver_private_data[SYSTEM_BUSES_NUMBER];
enum PacketizerCfg bus_to_packetizer_cfg[SYSTEM_BUSES_NUMBER];
deliver_function interface_to_deliver_function[INTERFACE_MAX_ID];
enum RemoteInterface bus_to_unique_port_map[SYSTEM_BUSES_NUMBER] = {INTERFACE_INVALID_ID};
int bus_has_any_destination_port[SYSTEM_BUSES_NUMBER] = {0};

static void initialize_devices()
{
    for(int i = 0; i < SYSTEM_BUSES_NUMBER; ++i)
    {
        bus_to_driver_send_function[i] = NULL;
        bus_to_driver_private_data[i] = NULL;
        bus_to_packetizer_cfg[i] = PACKETIZER_DEFAULT;
    }

    // register send functions

    // initialize devices
}

static void init_and_start_timers() {
    Timer_Config config_1;
    config_1.isEnabled = true;
    config_1.isAutoReloaded = false;
    config_1.isInterruptEnabled = false;
    config_1.isChained = false;
    config_1.reloadValue = TIMER_START_VALUE;

    Timer_Config config_2;
    config_2.isEnabled = true;
    config_2.isAutoReloaded = false;
    config_2.isInterruptEnabled = false;
    config_2.isChained = true;
    config_2.reloadValue = TIMER_START_VALUE;

    Timer_Apbctrl1_init(Timer_Id_3, &timer_1, defaultInterruptHandler);
    Timer_Apbctrl1_setBaseScalerReloadValue(&timer_1, TIMER_SCALER_VALUE);
    Timer_Apbctrl1_setConfigRegisters(&timer_1, &config_1);
    Timer_Apbctrl1_start(&timer_1);

    Timer_Apbctrl1_init(Timer_Id_4, &timer_2, defaultInterruptHandler);
    Timer_Apbctrl1_setBaseScalerReloadValue(&timer_2, TIMER_SCALER_VALUE);
    Timer_Apbctrl1_setConfigRegisters(&timer_2, &config_2);
    Timer_Apbctrl1_start(&timer_2);

    for(int i = 0; i<RUNTIME_THREAD_COUNT; i++)
    {
        threads_info[i].min_thread_execution_time = ULONG_MAX;
        threads_info[i].execution_time_counter = 0;
    }
}

rtems_id orchestratorcomponent_Semaphore;
rtems_id corecomponent_Semaphore;
rtems_id utilitycomponent_Semaphore;
rtems_id broker_Semaphore;

rtems_name generate_new_partition_task_name();
rtems_name generate_new_partition_timer_name();
rtems_name generate_new_partition_queue_name();
rtems_name generate_new_partition_semaphore_name();

rtems_name generate_new_partition_task_name()
{
    static rtems_name name = rtems_build_name('T',0,0,0);
    return name++;
}

rtems_name generate_new_partition_queue_name()
{
    static rtems_name name = rtems_build_name('Q',0,0,0);
    return name++;
}

rtems_name generate_new_partition_semaphore_name()
{
    static rtems_name name = rtems_build_name('S',0,0,0);
    return name++;
}

rtems_name generate_new_partition_timer_name()
{
    static rtems_name name = rtems_build_name('I',0,0,0);
    return name++;
}



rtems_id corecomponent_tc_Global_Queue = 0;

static rtems_id prv_corecomponent_tc_TCB = {0};

static RTEMS_MESSAGE_QUEUE_BUFFER( sizeof(struct ThreadCorecomponent_TcRequest) ) prv_corecomponent_tc_QueueBuffer[  1 ];

#define CORECOMPONENT_TC_STACK_SIZE ( 1024 > RTEMS_MINIMUM_STACK_SIZE ?  1024 : RTEMS_MINIMUM_STACK_SIZE)

RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char prv_corecomponent_tc_TaskBuffer[RTEMS_TASK_STORAGE_SIZE(CORECOMPONENT_TC_STACK_SIZE + MAX_TLS_SIZE, RTEMS_FLOATING_POINT)];

static void Create_Thread_corecomponent_tc(void)
{
    rtems_message_queue_config queueConfig = {
        .name = generate_new_partition_queue_name(),
        .maximum_pending_messages =  1,
        .maximum_message_size = sizeof(struct ThreadCorecomponent_TcRequest),
        .storage_area = prv_corecomponent_tc_QueueBuffer,
        .storage_size = sizeof(prv_corecomponent_tc_QueueBuffer),
        .storage_free = NULL,
        .attributes = RTEMS_DEFAULT_ATTRIBUTES
    };
    const rtems_status_code queueConstructionResult = rtems_message_queue_construct(&queueConfig,
                                  &corecomponent_tc_Global_Queue);

    assert(queueConstructionResult == RTEMS_SUCCESSFUL);

    rtems_task_config taskConfig = {
 	    .name = generate_new_partition_task_name(),
 	    .initial_priority =  1,
        .storage_area = prv_corecomponent_tc_TaskBuffer,
        .storage_size = sizeof(prv_corecomponent_tc_TaskBuffer),
        .maximum_thread_local_storage_size = MAX_TLS_SIZE,
        .storage_free = NULL,
        .initial_modes = RTEMS_PREEMPT,
        .attributes = TASK_ATTRIBUTES | RTEMS_FLOATING_POINT
    };

    const rtems_status_code taskConstructionResult = rtems_task_construct(&taskConfig,
                         &prv_corecomponent_tc_TCB);
    assert(taskConstructionResult == RTEMS_SUCCESSFUL);

    threads_info[corecomponent_tc].id = prv_corecomponent_tc_TCB;
    strncpy(threads_info[corecomponent_tc].name, "corecomponent_tc", MAX_THREAD_NAME_SIZE);
    threads_info[corecomponent_tc].name[MAX_THREAD_NAME_SIZE - 1] = '\0';
}


static void Start_Thread_corecomponent_tc(void)
{
    const rtems_status_code taskStartStatus = rtems_task_start(prv_corecomponent_tc_TCB,
                    corecomponent_tc_job,
                    0);
    assert(taskStartStatus == RTEMS_SUCCESSFUL);
}


rtems_id orchestratorcomponent_tm_Global_Queue = 0;

static rtems_id prv_orchestratorcomponent_tm_TCB = {0};

static RTEMS_MESSAGE_QUEUE_BUFFER( sizeof(struct ThreadOrchestratorcomponent_TmRequest) ) prv_orchestratorcomponent_tm_QueueBuffer[  1 ];

#define ORCHESTRATORCOMPONENT_TM_STACK_SIZE ( 1024 > RTEMS_MINIMUM_STACK_SIZE ?  1024 : RTEMS_MINIMUM_STACK_SIZE)

RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char prv_orchestratorcomponent_tm_TaskBuffer[RTEMS_TASK_STORAGE_SIZE(ORCHESTRATORCOMPONENT_TM_STACK_SIZE + MAX_TLS_SIZE, RTEMS_FLOATING_POINT)];

static void Create_Thread_orchestratorcomponent_tm(void)
{
    rtems_message_queue_config queueConfig = {
        .name = generate_new_partition_queue_name(),
        .maximum_pending_messages =  1,
        .maximum_message_size = sizeof(struct ThreadOrchestratorcomponent_TmRequest),
        .storage_area = prv_orchestratorcomponent_tm_QueueBuffer,
        .storage_size = sizeof(prv_orchestratorcomponent_tm_QueueBuffer),
        .storage_free = NULL,
        .attributes = RTEMS_DEFAULT_ATTRIBUTES
    };
    const rtems_status_code queueConstructionResult = rtems_message_queue_construct(&queueConfig,
                                  &orchestratorcomponent_tm_Global_Queue);

    assert(queueConstructionResult == RTEMS_SUCCESSFUL);

    rtems_task_config taskConfig = {
 	    .name = generate_new_partition_task_name(),
 	    .initial_priority =  1,
        .storage_area = prv_orchestratorcomponent_tm_TaskBuffer,
        .storage_size = sizeof(prv_orchestratorcomponent_tm_TaskBuffer),
        .maximum_thread_local_storage_size = MAX_TLS_SIZE,
        .storage_free = NULL,
        .initial_modes = RTEMS_PREEMPT,
        .attributes = TASK_ATTRIBUTES | RTEMS_FLOATING_POINT
    };

    const rtems_status_code taskConstructionResult = rtems_task_construct(&taskConfig,
                         &prv_orchestratorcomponent_tm_TCB);
    assert(taskConstructionResult == RTEMS_SUCCESSFUL);

    threads_info[orchestratorcomponent_tm].id = prv_orchestratorcomponent_tm_TCB;
    strncpy(threads_info[orchestratorcomponent_tm].name, "orchestratorcomponent_tm", MAX_THREAD_NAME_SIZE);
    threads_info[orchestratorcomponent_tm].name[MAX_THREAD_NAME_SIZE - 1] = '\0';
}


static void Start_Thread_orchestratorcomponent_tm(void)
{
    const rtems_status_code taskStartStatus = rtems_task_start(prv_orchestratorcomponent_tm_TCB,
                    orchestratorcomponent_tm_job,
                    0);
    assert(taskStartStatus == RTEMS_SUCCESSFUL);
}


rtems_id orchestratorcomponent_trigger_Global_Queue = 0;

static rtems_id prv_orchestratorcomponent_trigger_TCB = {0};

static RTEMS_MESSAGE_QUEUE_BUFFER( sizeof(struct ThreadOrchestratorcomponent_TriggerRequest) ) prv_orchestratorcomponent_trigger_QueueBuffer[  1 ];

#define ORCHESTRATORCOMPONENT_TRIGGER_STACK_SIZE ( 1024 > RTEMS_MINIMUM_STACK_SIZE ?  1024 : RTEMS_MINIMUM_STACK_SIZE)

RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char prv_orchestratorcomponent_trigger_TaskBuffer[RTEMS_TASK_STORAGE_SIZE(ORCHESTRATORCOMPONENT_TRIGGER_STACK_SIZE + MAX_TLS_SIZE, RTEMS_FLOATING_POINT)];

static void Create_Thread_orchestratorcomponent_trigger(void)
{
    rtems_message_queue_config queueConfig = {
        .name = generate_new_partition_queue_name(),
        .maximum_pending_messages =  1,
        .maximum_message_size = sizeof(struct ThreadOrchestratorcomponent_TriggerRequest),
        .storage_area = prv_orchestratorcomponent_trigger_QueueBuffer,
        .storage_size = sizeof(prv_orchestratorcomponent_trigger_QueueBuffer),
        .storage_free = NULL,
        .attributes = RTEMS_DEFAULT_ATTRIBUTES
    };
    const rtems_status_code queueConstructionResult = rtems_message_queue_construct(&queueConfig,
                                  &orchestratorcomponent_trigger_Global_Queue);

    assert(queueConstructionResult == RTEMS_SUCCESSFUL);

    rtems_task_config taskConfig = {
 	    .name = generate_new_partition_task_name(),
 	    .initial_priority =  1,
        .storage_area = prv_orchestratorcomponent_trigger_TaskBuffer,
        .storage_size = sizeof(prv_orchestratorcomponent_trigger_TaskBuffer),
        .maximum_thread_local_storage_size = MAX_TLS_SIZE,
        .storage_free = NULL,
        .initial_modes = RTEMS_PREEMPT,
        .attributes = TASK_ATTRIBUTES | RTEMS_FLOATING_POINT
    };

    const rtems_status_code taskConstructionResult = rtems_task_construct(&taskConfig,
                         &prv_orchestratorcomponent_trigger_TCB);
    assert(taskConstructionResult == RTEMS_SUCCESSFUL);

    threads_info[orchestratorcomponent_trigger].id = prv_orchestratorcomponent_trigger_TCB;
    strncpy(threads_info[orchestratorcomponent_trigger].name, "orchestratorcomponent_trigger", MAX_THREAD_NAME_SIZE);
    threads_info[orchestratorcomponent_trigger].name[MAX_THREAD_NAME_SIZE - 1] = '\0';
}


static void Start_Thread_orchestratorcomponent_trigger(void)
{
    const rtems_status_code taskStartStatus = rtems_task_start(prv_orchestratorcomponent_trigger_TCB,
                    orchestratorcomponent_trigger_job,
                    0);
    assert(taskStartStatus == RTEMS_SUCCESSFUL);
}


rtems_task Init(rtems_task_argument argument)
{
    initialize_devices();
    initialize_transport();
    initialize_routing();

    Cbi_Partition_Api_initialize();

    enum SystemBus valid_buses[SYSTEM_BUSES_NUMBER] = { BUS_INVALID_ID };
    Broker_initialize(valid_buses);
    init_and_start_timers();

    rtems_semaphore_create(rtems_build_name('l', 'o', 'c', 'k'),
                           1, // Initial value, unlocked
                           RTEMS_BINARY_SEMAPHORE,
                           0, // Priority ceiling
                           &broker_Semaphore);

    rtems_semaphore_create(generate_new_partition_semaphore_name(),
                           1, // Initial value, unlocked
                           RTEMS_BINARY_SEMAPHORE,
                           0, // Priority ceiling
                           &orchestratorcomponent_Semaphore);
    init_orchestratorcomponent();
    rtems_semaphore_create(generate_new_partition_semaphore_name(),
                           1, // Initial value, unlocked
                           RTEMS_BINARY_SEMAPHORE,
                           0, // Priority ceiling
                           &corecomponent_Semaphore);
    init_corecomponent();
    rtems_semaphore_create(generate_new_partition_semaphore_name(),
                           1, // Initial value, unlocked
                           RTEMS_BINARY_SEMAPHORE,
                           0, // Priority ceiling
                           &utilitycomponent_Semaphore);
    init_utilitycomponent();

    Create_Thread_corecomponent_tc();
    Create_Thread_orchestratorcomponent_tm();
    Create_Thread_orchestratorcomponent_trigger();

    Start_Thread_corecomponent_tc();
    Start_Thread_orchestratorcomponent_tm();
    Start_Thread_orchestratorcomponent_trigger();

    (void) rtems_task_delete( RTEMS_SELF );
}

// Additional functions required by the runtime, but not provided
// by the pre-qualified RTEMS libs

void abort()
{
    rtems_fatal( RTEMS_FATAL_SOURCE_EXIT, 0);
}

void __assert_func(const char * file, int line, const char * x, const char * y);

void __assert_func(const char * file, int line, const char * x, const char * y)
{
    rtems_fatal( RTEMS_FATAL_SOURCE_EXIT, 0);
}


#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER

#define CONFIGURE_MAXIMUM_PROCESSORS 2

#define CONFIGURE_MAXIMUM_BARRIERS 0

#define CONFIGURE_MAXIMUM_MESSAGE_QUEUES RUNTIME_TASK_COUNT

#define CONFIGURE_MAXIMUM_PARTITIONS 0

#define CONFIGURE_MAXIMUM_PERIODS 0

#define CONFIGURE_MAXIMUM_SEMAPHORES RUNTIME_FUNCTION_COUNT

#define CONFIGURE_MAXIMUM_TASKS RUNTIME_TASK_COUNT

#define CONFIGURE_MINIMUM_TASKS_WITH_USER_PROVIDED_STORAGE CONFIGURE_MAXIMUM_TASKS

#define CONFIGURE_MAXIMUM_TIMERS RUNTIME_TASK_COUNT

#define CONFIGURE_MAXIMUM_USER_EXTENSIONS 0

#define CONFIGURE_MICROSECONDS_PER_TICK 1000

#define CONFIGURE_MAXIMUM_FILE_DESCRIPTORS 0

#define CONFIGURE_DISABLE_NEWLIB_REENTRANCY

#define CONFIGURE_APPLICATION_DISABLE_FILESYSTEM

#define CONFIGURE_MAXIMUM_THREAD_LOCAL_STORAGE_SIZE MAX_TLS_SIZE

#define CONFIGURE_RTEMS_INIT_TASKS_TABLE

#define CONFIGURE_INIT_TASK_ATTRIBUTES TASK_ATTRIBUTES | RTEMS_FLOATING_POINT

#define CONFIGURE_INIT_TASK_INITIAL_MODES RTEMS_DEFAULT_MODES

#define CONFIGURE_INIT_TASK_CONSTRUCT_STORAGE_SIZE TASK_STORAGE_SIZE

#define CONFIGURE_INIT

#include <rtems/confdefs.h>
