/* File generated by kazoo for TASTE - do not edit */
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#define RUNTIME_TASK_COUNT ( 1 + 1 + 1 )
#define RUNTIME_FUNCTION_COUNT ( 1 + 1 + (1 * 2) )

#define PROVIDED_INTERFACE_COUNT ( 0 + 1 )

extern "C" {
#include <fero.h>
#include <Broker.h>
#include <DriverHelper.h>
#include "spacepartition_interface.h"
#include "transport.h"
#include "routing.h"
#include "thread_spacesegment_tc.h"
#include "interfaces_info.h"
#include "arduino_serial.h"

extern void init_spacesegment(void);
static arduino_serial_private_data uart0_data;

void Broker_acquire_lock()
{
    // NOP
}

void Broker_release_lock()
{
    // NOP
}

}

FERO_SCHEDULER_BUFFER(scheduler_buffer, RUNTIME_TASK_COUNT);
Fero_Scheduler scheduler;

driver_send_function bus_to_driver_send_function[SYSTEM_BUSES_NUMBER];
void* bus_to_driver_private_data[SYSTEM_BUSES_NUMBER];
enum PacketizerCfg bus_to_packetizer_cfg[SYSTEM_BUSES_NUMBER];
deliver_function interface_to_deliver_function[INTERFACE_MAX_ID];
enum RemoteInterface bus_to_unique_port_map[SYSTEM_BUSES_NUMBER] = {INTERFACE_INVALID_ID};
int bus_has_any_destination_port[SYSTEM_BUSES_NUMBER] = {0};

static void initialize_devices()
{
    for(int i = 0; i < SYSTEM_BUSES_NUMBER; ++i)
    {
        bus_to_driver_send_function[i] = NULL;
        bus_to_driver_private_data[i] = NULL;
        bus_to_packetizer_cfg[i] = PACKETIZER_DEFAULT;
    }

    // register send functions
    bus_to_driver_send_function[BUS_BUS_1] = ArduinoSerialSend;
    bus_to_driver_private_data[BUS_BUS_1] = &uart0_data;
    bus_to_packetizer_cfg[BUS_BUS_1] = get_device_packetizer_cfg(DEVICE_NODE_2_UART0);

    // initialize devices
    ArduinoSerialInit(&uart0_data,
                    BUS_BUS_1,
                    DEVICE_NODE_2_UART0,
                    (Arduino_Serial_Conf_T*)get_device_configuration(DEVICE_NODE_2_UART0),
                    (Arduino_Serial_Conf_T*)get_remote_device_configuration(DEVICE_NODE_2_UART0));
}


FERO_QUEUE_BUFFER(spacesegment_tc_buffer, 1, sizeof(struct ThreadSpacesegment_TcRequest));
Fero_Tasklet spacesegment_tc_tasklet;
Fero_Queue spacesegment_tc_queue;

static void create_tasklet_spacesegment_tc(void)
{
    Fero_Tasklet_init(
        &spacesegment_tc_tasklet,
        "spacesegment_tc_tasklet",
        spacesegment_tc_job,
        NULL
    );

    Fero_Scheduler_addTasklet(
        &scheduler,
        &spacesegment_tc_tasklet,
        0
    );

    Fero_Queue_init(
        &spacesegment_tc_queue,
        1,
        sizeof(struct ThreadSpacesegment_TcRequest),
        spacesegment_tc_buffer
    );

    Fero_Tasklet_setQueueActivated(
        &spacesegment_tc_tasklet,
        &spacesegment_tc_queue
    );
}


void setup()
{
    initialize_devices();
    initialize_transport();
    initialize_routing();

    enum SystemBus valid_buses[SYSTEM_BUSES_NUMBER] = { BUS_INVALID_ID };
    unsigned buses_index = 0;
    valid_buses[buses_index++] = BUS_BUS_1;
    Broker_initialize(valid_buses);

    init_spacesegment();

    create_tasklet_spacesegment_tc();
}

void loop()
{
    // Fero_TimeNs time = millis() * 1000000;
    // Workaround for millis not working on AVR Qemu
    static Fero_TimeNs time = 0;
    time += 1000000;
    Fero_Scheduler_invoke(&scheduler, time);
}